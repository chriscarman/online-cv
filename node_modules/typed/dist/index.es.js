function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function isArray(value) {
  return Array.isArray(value);
}
function isNull(value) {
  return value === null;
}
function isObject(value) {
  return typeof value === "object" && !isNull(value) && !isArray(value);
}
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
function isOk(result) {
  return result.ok;
}
function isErr(result) {
  return !isOk(result);
}
const map = (struct, mapFn) => (input) => {
  const result = struct(input);
  return isOk(result) ? mapFn(result.value) : result;
};
const chain = (struct, ...fns) => (input) => {
  const result = struct(input);
  if (isErr(result))
    return result;
  return ok(fns.reduce((acc, fn) => fn(acc), result.value));
};
function unwrap(result) {
  if (isOk(result)) {
    return result.value;
  } else {
    throw result.error;
  }
}
function unwrapOr(result, def) {
  return isOk(result) ? result.value : def;
}
const any = (input) => ok(input);
class StructError extends Error {
  constructor(message, info = { path: [] }) {
    super(message);
    this.message = message;
    this.info = info;
  }
  toJSON() {
    return {
      message: this.message,
      info: this.info
    };
  }
}
const array = (struct, msg = "Expecting array") => (input) => {
  if (!isArray(input))
    return err(new StructError(msg, { input, path: [] }));
  const arr = new Array(input.length);
  for (const [i, x] of input.entries()) {
    const result = struct(x);
    if (isErr(result)) {
      result.error.info.path.unshift(i.toString());
      return result;
    }
    arr[i] = result.value;
  }
  return ok(arr);
};
const asArray = (struct, msg = "Expecting array") => {
  const fn = array(struct, msg);
  return (input) => isArray(input) ? fn(input) : fn([input]);
};
const asOnly = (struct, index = 0) => (input) => Array.isArray(input) ? struct(input[index]) : struct(input);
const boolean = (msg = "Expecting boolean") => (input) => isBoolean(input) ? ok(input) : err(new StructError(msg, { input, path: [] }));
const date = (msg = "Expecting date") => (input) => isDate(input) ? ok(new Date(input.getTime())) : err(new StructError(msg, { input, path: [] }));
const asDate = (msg) => {
  const fn = date(msg);
  return (input) => isString(input) || isNumber(input) ? fn(new Date(input)) : fn(input);
};
const defaulted = (struct, defaultValue) => (input) => isUndefined(input) ? ok(defaultValue) : struct(input);
const enums = (e, msg) => {
  const values = Object.values(e);
  msg != null ? msg : msg = `Expecting one of ${values.join(", ")}`;
  return (input) => values.includes(input) ? ok(input) : err(new StructError(msg, { input, path: [] }));
};
const intersection = (structs) => (input) => {
  const obj = /* @__PURE__ */ Object.create(null);
  for (const struct of structs) {
    const result = struct(input);
    if (isErr(result))
      return result;
    Object.assign(obj, result.value);
  }
  return ok(obj);
};
const literal = (constant, msg = "Expecting literal") => (input) => input === constant ? ok(input) : err(new StructError(msg, { input, path: [] }));
const nullable = (struct) => (input) => isNull(input) ? ok(input) : struct(input);
const number = (msg = "Expecting number") => (input) => isNumber(input) ? ok(input) : err(new StructError(msg, { input, path: [] }));
const asNumber = (msg) => {
  const fn = number(msg);
  return (input) => fn(Number(input));
};
const object = (shape, msg = "Expecting object") => {
  const entries = Object.entries(shape);
  return (input) => {
    if (!isObject(input))
      return err(new StructError(msg, { input, path: [] }));
    const obj = /* @__PURE__ */ Object.create(null);
    for (const [key, struct] of entries) {
      const result = struct(input[key]);
      if (isErr(result)) {
        result.error.info.path.unshift(key);
        return result;
      }
      obj[key] = result.value;
    }
    return ok(obj);
  };
};
const optional = (struct) => (input) => isUndefined(input) ? ok(input) : struct(input);
const record = (key, value, msg = "Expecting object") => (input) => {
  if (!isObject(input))
    return err(new StructError(msg, { input, path: [] }));
  const obj = /* @__PURE__ */ Object.create(null);
  for (const [k, v] of Object.entries(input)) {
    const kr = key(k);
    if (isErr(kr)) {
      kr.error.info.path.unshift(k);
      return kr;
    }
    const vr = value(v);
    if (isErr(vr)) {
      vr.error.info.path.unshift(k);
      return vr;
    }
    obj[kr.value] = vr.value;
  }
  return ok(obj);
};
const string = (msg = "Expecting string") => (input) => isString(input) ? ok(input) : err(new StructError(msg, { input, path: [] }));
const asString = (msg) => {
  const fn = string(msg);
  return (input) => fn(String(input));
};
const tuple = (structs, msg = "Expecting tuple") => {
  const entries = [...structs.entries()];
  return (input) => {
    if (!isArray(input))
      return err(new StructError(msg, { input, path: [] }));
    const arr = new Array(structs.length);
    for (const [i, struct] of entries) {
      const result = struct(input[i]);
      if (isErr(result)) {
        result.error.info.path.unshift(i.toString());
        return result;
      }
      arr[i] = result.value;
    }
    return ok(arr);
  };
};
const union = (structs, msg = "Expecting one of the specified structs") => {
  return (input) => {
    for (const struct of structs) {
      const result = struct(input);
      if (isOk(result))
        return result;
    }
    return err(new StructError(msg, { input, path: [] }));
  };
};
const unknown = (input) => ok(input);
export { StructError, any, array, asArray, asDate, asNumber, asOnly, asString, boolean, chain, date, defaulted, enums, err, intersection, isErr, isOk, literal, map, nullable, number, object, ok, optional, record, string, tuple, union, unknown, unwrap, unwrapOr };
